import datetime as dt
from calendar import monthrange

import attr
import numpy as np
import pandas as pd

from person import Person, BOOKING_COLUMN_NAMES


def booking_lead_time_of_customer_universe(gamma, lead_time):
    alpha = gamma
    lambda_max = 100 # number of rooms
    normalization = 2 / np.pi
    # Worth adding a drop towards 0 rate at the end, but left for later
    return normalization * alpha * lambda_max / (np.power(alpha, 2) + np.power(lead_time, 2))

def lead_days_distribution(gamma, max_lead_days):
    result = [booking_lead_time_of_customer_universe(gamma, lead_time)
                              for lead_time in range(max_lead_days+1)]
    return result



def probability_day_of_week(weekday):
    return 1/7
    weekday_probability = 0.18
    if weekday in [4, 5]:
        return weekday_probability
    else:
        return (1 - weekday_probability * 2) / 5


def month_probability(month):
    # from demo merchant, for now
    month_probabilities = {
        1: 0.2,
        2: 0.05,
        3: 0.1,
        4: 0.15,
        5: 0.2,
        6: 0.35,
        7: 0.3,
        8: 0.25,
        9: 0.25,
        10: 0.2,
        11: 0.15,
        12: 0.1,
    }
    return month_probabilities[month] / 2.3


@attr.s
class Market(object):
    start_reserved_night_date = attr.ib()
    end_reserved_night_date = attr.ib()
    average_number_of_potential_customers = attr.ib()
    minimum_budget_in_population = attr.ib(default=40)
    gamma = attr.ib(default=10)

    _budgets = attr.ib(default=None)
    _first_start_dates = attr.ib(default=None)
    _number_of_potential_customers_per_month = attr.ib(default=None)

    #@profile
    def initialize_market(self):
	
	#### Define number of customers
        total_potential_customers = self.average_number_of_potential_customers * \
                                    (self.end_reserved_night_date - self.start_reserved_night_date).days
        
	#### Define budget of each customer
        self._budgets = self._initialize_budgets(total_potential_customers)

	#### Define when customer wants to book (day,month,year)
        cumulative_sum = np.cumsum([month_probability(i) for i in range(1, 13)])
        months = [self._calculate_month(uniform,cumulative_sum) for uniform in np.random.uniform(0, 1, total_potential_customers)]
        years = [self._calculate_year(uniform) for uniform in np.random.uniform(0, 1, total_potential_customers)]

        cumulative_sum_weekday = np.cumsum([probability_day_of_week(i) for i in range(7)])
        self._first_start_dates = [dt.datetime(year, month, self._calculate_day(year, month,cumulative_sum_weekday))
                                   for year, month in zip(years, months)]
	### Define how many customers per month
        self._fill_generation_statistics()
    @profile
    def _initialize_budgets(self, total_potential_customers):
	#### Take a normal distribution, truncated at minimum price.
        budgets = np.abs(np.random.standard_normal(total_potential_customers * self.minimum_budget_in_population)) * self.minimum_budget_in_population # this controls the prices
        budgets = budgets[budgets > self.minimum_budget_in_population]
        budgets = budgets[:total_potential_customers]
        if len(budgets) != total_potential_customers:
            raise Exception
        return budgets
    
    #@profile
    def generate_bookings_for_reserved_night_date(self, reserved_night_date, revenue_manager, persons):
        if persons is None:
            persons = self._create_persons(reserved_night_date)

        start_date = reserved_night_date - dt.timedelta(days=self.gamma * 6)
        end_date = reserved_night_date + dt.timedelta(days=1)

        for extra_days in range((end_date-start_date).days):
            time = start_date + dt.timedelta(days=extra_days)
            rates_table_np = revenue_manager.get_rates_table_for_reserved_night_date(time, reserved_night_date)
            bookings_df = self.generate_bookings(time,rates_table_np, persons)

            if bookings_df is None:
                continue
            revenue_manager.add_bookings(bookings_df)
        return revenue_manager

    @profile
    def generate_bookings(self, time,rates_table_np, persons):
        bookings_df = None

        for person in persons:

            temp_bookings_df = person.generate_bookings(time, rates_table_np)

            if temp_bookings_df is None:
                continue
            if bookings_df is None:
                bookings_df = temp_bookings_df
            else:
                bookings_df = np.append(bookings_df,temp_bookings_df,axis=0)
        return bookings_df
    @profile
    def _create_persons(self, reserved_night_date):
        persons = []
        budgets = self._budgets[np.array(self._first_start_dates) == reserved_night_date]
        lead_days_dist = lead_days_distribution(self.gamma, self.gamma * 6)
        #print("HERE",budgets)
        for i in range(len(budgets)):
            # create individual person
            lead_days_to_use = np.random.choice(np.arange(self.gamma * 6+1),
                                                p=lead_days_dist / np.sum(lead_days_dist))
            length_of_stay = 1 # for now we just do an LOS of 1
            budget = budgets[i]
            start_dates = [reserved_night_date]
            persons.append(
                Person(
                    budget=budget,
                    possible_start_dates=np.array(start_dates),
                    possible_end_dates=np.array([start_date+dt.timedelta(days=length_of_stay) for start_date in start_dates]),
                    possible_booking_lead_times=np.array([lead_days_to_use]),
                    type_of_person='transient'
                )
            )
        return persons

 

    @staticmethod
    #@profile
    def _calculate_day(year, month,cumulative_sum_weekday):
        
        weekday = len(cumulative_sum_weekday[cumulative_sum_weekday < np.random.uniform()])
        possible_weekdays = [day for day in range(1, monthrange(year, month)[1] + 1) if dt.datetime(year, month, day).weekday() == weekday]
        cumulative_sum = np.arange(0, 1.001, 1/len(possible_weekdays))[1:]
        return possible_weekdays[len(cumulative_sum[cumulative_sum < np.random.uniform()])]

    @staticmethod
    #@profile
    def _calculate_month(uniform_distribution_value,cumulative_sum):
        #cumulative_sum = np.cumsum([month_probability(i) for i in range(1, 13)])
        return len(cumulative_sum[cumulative_sum < uniform_distribution_value]) + 1

    def _calculate_year(self, uniform_distribution_value):
        years = range(self.start_reserved_night_date.year, self.end_reserved_night_date.year + 1)
        if len(years) == 1:
            return self.start_reserved_night_date.year
        cumulative_sum = np.cumsum(np.arange(0, 1, 1/len(years)))
        return years[len(cumulative_sum[cumulative_sum < uniform_distribution_value])]

    def _fill_generation_statistics(self):
        self._number_of_potential_customers_per_month = [0] * 12
        for date in self._first_start_dates:
            month_index = date.month - 1
            self._number_of_potential_customers_per_month[month_index] += 1

